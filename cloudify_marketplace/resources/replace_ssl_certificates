#! /usr/bin/env python
import json
import logging
import logging.handlers
import os
import shutil
import subprocess
import time

import yaml
from cloudify_rest_client import CloudifyClient
from cloudify_cli.utils import get_auth_header

target_file = '/tmp/cloudify_ssl_certificate_replacement.json'

# Config paths
MGMTWORKER_CONFIG_PATH = '/opt/mgmtworker/work/broker_config.json'
RESTSERVICE_CONFIG_PATH = '/opt/manager/cloudify-rest.conf'
AMQPINFLUX_CONFIG_PATH = '/etc/sysconfig/cloudify-amqpinflux'

# Executable paths
RABBITMQCTL = '/sbin/rabbitmqctl'
SED = '/bin/sed'

logger = logging.getLogger('cloudify_security_config')
# TODO: logging.INFO or maybe look for a flag
logger.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address='/dev/log')
logger.addHandler(handler)


if __name__ == '__main__':
    logger.debug('Looking for cloudify security configuration json')
    if os.path.isfile(target_file):
        logger.info('Found cloudify security configuration, processing')
        # Even if the writing is for some reason partially complete,
        # we'll be re-running in at most 1 minute anyway
        with open(target_file) as target_file_handle:
            details = json.load(target_file_handle)

        # TODO: Actually implement this in configure.py
        details['new_broker_username'] = 'cloudifythesecond'
        details['new_broker_password'] = 'cloudfiy23424'
        details['new_manager_username'] = 'cloudifythethird'
        details['new_manager_password'] = 'cloudi54321'

        # Add the new rabbit user
        subprocess.call([RABBITMQCTL, 'add_user',
                         details['new_broker_username'],
                         details['new_broker_password']])
        subprocess.call([RABBITMQCTL, 'set_permissions',
                         details['new_broker_username'],
                         '.*', '.*', '.*'])

        logger.debug('JSON: {contents}'.format(contents=str(details)))
        # We're done, we don't need the details file any more
        # Remove the file now in case we take more than a minute to run
        os.unlink(target_file)
        logger.debug('Deleted security configuration file')

        execution_id = details['execution_id']
        auth_header = get_auth_header(
            username=details['cloudify_username'],
            password=details['cloudify_password'],
        )
        cert_path = '/root/cloudify/server.crt'

        c = CloudifyClient(
            headers=auth_header,
            cert=cert_path,
            trust_all=False,
            port=443,
            protocol='https',
        )

        logger.info('Waiting for configuration workflow to finish...')
        while c.executions.get(execution_id)['status'] != 'terminated':
            time.sleep(0.5)
        logger.info('...configuration workflow finished.')

        # Update the cert in the provider context
        # Find the broker public cert
        for temp_cert, _ in details['new_certs']:
            if 'broker-public' in temp_cert:
                broker_cert_path = temp_cert
                break
        with open(broker_cert_path) as cert_handle:
            public_cert = cert_handle.read()
        # And update the context with it
        name = c.manager.get_context()['name']
        context = c.manager.get_context()['context']
        context['cloudify']['cloudify_agent']['broker_ssl_cert'] = public_cert
        context['cloudify']['cloudify_agent']['broker_user'] = \
            details['new_broker_username']
        context['cloudify']['cloudify_agent']['broker_pass'] = \
            details['new_broker_password']
        c.manager.update_context(name, context)
        logger.info('Updated broker cert in provider context with new cert.')

        # Don't restart the same service more than once
        services = set(details['restart_services'])

        # Stop services to try to avoid logging meaningless errors while certs
        # are being replaced
        for service in details['restart_services']:
            logger.info('Stopping {service}'.format(service=service))
            # If it fails to stop that's not a critical problem
            subprocess.call(['/sbin/service', service, 'stop'])

        # Replace certs
        for temp_cert, destination in details['new_certs']:
            logger.info('Copying {temp} to {destination}'.format(
                temp=temp_cert,
                destination=destination,
            ))
            shutil.copyfile(temp_cert, destination)

        # Fix broker credentials in conf files
        # For the management worker
        with open(MGMTWORKER_CONFIG_PATH) as conf_handle:
            mgmtworker_config = json.loads(conf_handle.read())
        mgmtworker_config['broker_username'] = details['new_broker_username']
        mgmtworker_config['broker_password'] = details['new_broker_password']
        with open(MGMTWORKER_CONFIG_PATH, 'w') as conf_handle:
            conf_handle.write(json.dumps(mgmtworker_config))
        # And for the rest service
        with open(RESTSERVICE_CONFIG_PATH) as conf_handle:
            restservice_config = yaml.load(conf_handle.read())
        restservice_config['amqp_username'] = details['new_broker_username']
        restservice_config['amqp_password'] = details['new_broker_password']
        with open(RESTSERVICE_CONFIG_PATH, 'w') as conf_handle:
            # Disable default flow style to maintain configish layout
            conf_handle.write(yaml.dump(restservice_config,
                              default_flow_style=False))
        # And the amqp-influx service
        subprocess.check_call([
            SED, '-i',
            's/AMQP_USERNAME=.*/AMQP_USERNAME={new_username}/'.format(
                new_username=details['new_broker_username'],
            ),
            AMQPINFLUX_CONFIG_PATH,
        ])
        subprocess.check_call([
            SED, '-i',
            's/AMQP_PASSWORD=.*/AMQP_PASSWORD={new_password}/'.format(
                new_password=details['new_broker_password'],
            ),
            AMQPINFLUX_CONFIG_PATH,
        ])

        # Update the manager credentials
        username = details['new_manager_username']
        password = details['new_manager_password']
        MANAGER_REST_SECUIRTY_FILE = '/opt/manager/rest-security.conf'
        with open(MANAGER_REST_SECUIRTY_FILE) as sec_file:
            sec_data = json.loads(sec_file.read())
        user = sec_data[
            'userstore_driver']['properties']['userstore']['users'][0]
        sec_data['admin_username'] = user['username'] = username
        sec_data['admin_password'] = user['password'] = password
        with open(MANAGER_REST_SECUIRTY_FILE, 'w') as sec_file:
            sec_file.write(json.dumps(sec_data))

        # Start services
        for service in details['restart_services']:
            logger.info('Starting {service}'.format(service=service))
            # Call restart in case any of them didn't stop properly
            subprocess.check_call(['/sbin/service', service, 'restart'])

        # Clean up temporary certificates
        logger.info('Deleting temporary certificates')
        for temp_cert, _ in details['new_certs']:
            logger.debug('Trying to delete {temp}'.format(temp=temp_cert))
            try:
                os.unlink(temp_cert)
                logger.debug('Deleted {temp}'.format(temp=temp_cert))
            except OSError:
                # Already deleted this temp cert
                logger.debug(
                    'Could not delete {temp}. '
                    'Assuming already deleted.'.format(temp=temp_cert)
                )

        # And delete the old rabbit user
        subprocess.call([RABBITMQCTL, 'delete_user',
                         details['new_broker_username']])

        # And we can stop running this cron job, too!
        logger.info('Stopping security configuration cron job')
        os.unlink('/etc/cron.d/cloudify_security_configuration')
